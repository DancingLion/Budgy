import { Router } from 'express';
import { prisma } from '../db/prisma';
import { authenticateToken } from '../middleware/auth';
import { addDays, addMonths, addWeeks, addYears } from 'date-fns';

const router = Router();

// 수입원 추가
router.post('/sources', authenticateToken, async (req: any, res) => {
    try {
        const { name, amount, frequency, nextPaymentDate } = req.body;
        const source = await prisma.incomeSource.create({
            data: {
                userId: req.user.id,
                name,
                amount,
                frequency,
                nextPaymentDate: new Date(nextPaymentDate)
            }
        });
        res.json(source);
    } catch (error) {
        console.error('수입원 추가 실패:', error);
        res.status(500).json({ error: '수입원 추가 중 오류가 발생했습니다.' });
    }
});

// 수입원 목록 조회
router.get('/sources', authenticateToken, async (req: any, res) => {
    try {
        const sources = await prisma.incomeSource.findMany({
            where: {
                userId: req.user.id,
                isActive: true
            },
            orderBy: {
                createdAt: 'desc'
            }
        });
        res.json(sources);
    } catch (error) {
        console.error('수입원 조회 실패:', error);
        res.status(500).json({ error: '수입원 조회 중 오류가 발생했습니다.' });
    }
});

// 수입원 삭제 (비활성화)
router.delete('/sources/:id', authenticateToken, async (req: any, res) => {
    try {
        const { id } = req.params;
        const source = await prisma.incomeSource.findFirst({
            where: {
                id,
                userId: req.user.id
            }
        });

        if (!source) {
            return res.status(404).json({ error: '수입원을 찾을 수 없습니다.' });
        }

        await prisma.incomeSource.update({
            where: { id },
            data: { isActive: false }
        });

        res.json({ message: '수입원이 삭제되었습니다.' });
    } catch (error) {
        console.error('수입원 삭제 실패:', error);
        res.status(500).json({ error: '수입원 삭제 중 오류가 발생했습니다.' });
    }
});

// 수입 내역 추가
router.post('/transactions', authenticateToken, async (req: any, res) => {
    try {
        const { incomeSourceId, amount, date, description } = req.body;
        const transaction = await prisma.incomeTransaction.create({
            data: {
                userId: req.user.id,
                incomeSourceId,
                amount,
                date: new Date(date),
                description
            }
        });
        res.json(transaction);
    } catch (error) {
        console.error('수입 내역 추가 실패:', error);
        res.status(500).json({ error: '수입 내역 추가 중 오류가 발생했습니다.' });
    }
});

// 수입 내역 조회
router.get('/transactions', authenticateToken, async (req: any, res) => {
    try {
        const { startDate, endDate } = req.query;
        const transactions = await prisma.incomeTransaction.findMany({
            where: {
                userId: req.user.id,
                date: {
                    gte: startDate ? new Date(startDate) : undefined,
                    lte: endDate ? new Date(endDate) : undefined
                }
            },
            include: {
                incomeSource: true
            },
            orderBy: {
                date: 'desc'
            }
        });
        res.json(transactions);
    } catch (error) {
        console.error('수입 내역 조회 실패:', error);
        res.status(500).json({ error: '수입 내역 조회 중 오류가 발생했습니다.' });
    }
});

// 자동 수입 업데이트 (CRON job에서 호출)
router.post('/auto-update', async (req, res) => {
    try {
        const today = new Date();
        const activeSources = await prisma.incomeSource.findMany({
            where: {
                isActive: true,
                nextPaymentDate: {
                    lte: today
                }
            }
        });

        for (const source of activeSources) {
            // 수입 내역 생성
            await prisma.incomeTransaction.create({
                data: {
                    userId: source.userId,
                    incomeSourceId: source.id,
                    amount: source.amount,
                    date: source.nextPaymentDate,
                    isAutoGenerated: true,
                    description: `${source.name} - 자동 생성됨`
                }
            });

            // 다음 지급일 계산
            let nextDate = new Date(source.nextPaymentDate);
            switch (source.frequency) {
                case 'WEEKLY':
                    nextDate = addWeeks(nextDate, 1);
                    break;
                case 'BIWEEKLY':
                    nextDate = addWeeks(nextDate, 2);
                    break;
                case 'MONTHLY':
                    nextDate = addMonths(nextDate, 1);
                    break;
                case 'ANNUAL':
                    nextDate = addYears(nextDate, 1);
                    break;
                default:
                    continue; // ONE_TIME은 업데이트하지 않음
            }

            // 수입원 업데이트
            await prisma.incomeSource.update({
                where: { id: source.id },
                data: { nextPaymentDate: nextDate }
            });
        }

        res.json({ message: '자동 수입이 업데이트되었습니다.' });
    } catch (error) {
        console.error('Error updating automatic income:', error);
        res.status(500).json({ error: '자동 수입 업데이트 중 오류가 발생했습니다.' });
    }
});

// 총 수입 계산 및 업데이트
router.post('/total-update', authenticateToken, async (req: any, res) => {
    try {
        const userId = req.user.id;
        const today = new Date();

        // 활성화된 수입원 목록 조회
        const sources = await prisma.incomeSource.findMany({
            where: {
                userId,
                isActive: true
            }
        });

        // 월간 총 수입 계산
        const monthlyIncome = sources.reduce((total, source) => {
            switch (source.frequency) {
                case 'WEEKLY':
                    return total + (source.amount * 4);
                case 'BIWEEKLY':
                    return total + (source.amount * 2);
                case 'MONTHLY':
                    return total + source.amount;
                case 'ANNUAL':
                    return total + (source.amount / 12);
                case 'ONE_TIME':
                    const nextPayment = new Date(source.nextPaymentDate);
                    const currentMonth = today.getMonth();
                    const currentYear = today.getFullYear();
                    return total + (
                        nextPayment.getMonth() === currentMonth &&
                            nextPayment.getFullYear() === currentYear ?
                            source.amount : 0
                    );
                default:
                    return total;
            }
        }, 0);

        // 사용자 정보 업데이트
        await prisma.user.update({
            where: { id: userId },
            data: { income: monthlyIncome }
        });

        res.json({ monthlyIncome });
    } catch (error) {
        console.error('Error calculating total income:', error);
        res.status(500).json({ error: '총 수입 계산 중 오류가 발생했습니다.' });
    }
});

// 총 수입 조회
router.get('/total', authenticateToken, async (req: any, res) => {
    try {
        const userId = req.user.id;
        const user = await prisma.user.findUnique({
            where: { id: userId },
            select: { income: true }
        });

        res.json({ monthlyIncome: user?.income || 0 });
    } catch (error) {
        console.error('Error getting total income:', error);
        res.status(500).json({ error: '총 수입 조회 중 오류가 발생했습니다.' });
    }
});

export default router;